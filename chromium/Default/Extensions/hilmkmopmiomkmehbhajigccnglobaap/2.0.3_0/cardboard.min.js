angular.module('cardboard.filters',[]);

angular.module('cardboard.filters')

.filter('humanize', function () {
    return function humanize (input) {
        var isUpper = function (s) {
            return !/[^a-z\xC0-\xFF]/.test(s.toLowerCase()) && s.toUpperCase() === s;
        };

        input = input.replace(/(^\s*|\s*$)/g, '').replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
        if (isUpper(input.charAt(0))) {
          input = '_' + input;
        }

        input = input.replace(/_id$/,'').replace(/_/g, ' ').replace(/(^\s*|\s*$)/g, '');
        input = input.substr(0, 1).toUpperCase() + input.substring(1).toLowerCase();

        return input;
    }
});

angular.module('cardboard.filters')

.filter('host', function () {
  return function ( input ) {
    var matches,
        output = "",
        urls = /\w+:\/\/([\w|\.]+)/;

    matches = urls.exec( input );

    if ( matches !== null ) output = matches[1];

    return output;
  };
});

angular.module('cardboard.filters')

.filter('fromNow', function() {
    return function(dateString) {
        return moment(new Date(dateString)).fromNow();
    };
});

angular.module('cardboard.filters')

.filter('filename', function() {
    return function(filename) {
        return filename.replace(/^.*[\\\/]/, '');
    }
});

angular.module('cardboard.filters')

.filter('bytes', function() {
    return function(bytes, precision) {
        if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) return '-';
        if (typeof precision === 'undefined') precision = 1;
        var units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'],
            number = Math.floor(Math.log(bytes) / Math.log(1024));
        return (bytes / Math.pow(1024, Math.floor(number))).toFixed(precision) +  ' ' + units[number];
    }
});

angular.module('cardboard.factories',[]);

angular.module('cardboard.factories')

.factory('TrendsFactory', [
    '$http',
    'DefaultSettings',
    function($http, DefaultSettings){
    var Trends = {};

    function fromNetwork(){
        var deferred = Promise.defer();
        $http.get(DefaultSettings.trends.url)
        // Load trends (even if disabled to allow quick toggle)
        .success(function(data) {
            var allTrends = [];
            for(var i=0; i<12; i++)
                if(data[i]) // some data is undefined
                    allTrends = allTrends.concat(data[i]);

            // update the lastRefresh Date and cache trends data
            chrome.storage.local.setAsync({
                'trends': {
                    'lastRefresh': new Date().toString(),
                    'data': allTrends
                }
            });
            // Note: trends data is stored in cache (ie. chrome local storage, not sync storage)
            // because it would take up too much space and exceed the QUOTA_BYTES_PER_ITEM limit
            deferred.resolve(shuffle(allTrends));
        })
        .error(function(error){
            toast("Can't load trends", 4000);
            deferred.resolve(['Google Trends']);
        });

        return deferred.promise;
    }

    Trends.get = function(){
        return chrome.storage.local.getAsync("trends")
        .then(function(cache){
            // if there is nothing in cache we load trends from network
            if(!cache.trends)
                return fromNetwork();
            // if cache is outdated (1 day)
            else if(!(new Date(cache.trends.lastRefresh).isSameDateAs(new Date())))
                return fromNetwork();
            // we return the cached trends
            else
                return shuffle(cache.trends.data);
        });
    }

    return Trends;

}]);

// Determine if 2 dates are the same day (time independent)
Date.prototype.isSameDateAs = function(pDate) {
    return (
        this.getFullYear() === pDate.getFullYear() &&
        this.getMonth() === pDate.getMonth() &&
        this.getDate() === pDate.getDate()
    );
};

// Shuffles an array
function shuffle(o){
    for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
}

angular.module('cardboard.factories')

.factory('ChromeSettings',[function(){

    var promisifyOptions = {promisifier: function noErrPromisifier(originalMethod){
        return function promisified(){
             var args = [].slice.call(arguments);
             var self = this;
             return new Promise(function(resolve,reject){
                 args.push(resolve);
                 originalMethod.apply(self,args);
             });
        };
    }};

    function promisify(api){
        for(var i in api){
            // if there is a "promisified" method. It's already promisified
            if(api[i].name == "promisified")
                return api;
        }
        return Promise.promisifyAll(api, promisifyOptions);
    }

    promisify(chrome.storage.sync);
    promisify(chrome.storage.local);
    promisify(chrome.management);


    function versionDiff(newVersion, oldVersion){
        // if version is not even a string we know it's a new major version
        if(typeof oldVersion !== 'string')
            return "major";

        var newV = newVersion.split('.');
        var oldV = oldVersion.split('.');

        for(var i in newV){
            // if number is greater it's a new version
            if(newV[i] > oldV[i]){
                // if it's the first iteration it's a major
                if(i == 0)
                    return "major";
                // if it's the second iteration it's a minor
                else if(i == 1)
                    return "minor";
                // if it's the third or more iteration it's a patch
                else
                    return "patch";
            }
        }
        return;
    }

    return {
        // returns settings {extensionInfo, sync, local, update<optional>}
        get: function(){
            return Promise.all([
                chrome.management.getSelfAsync(),
                chrome.storage.sync.getAsync(null),
                chrome.storage.local.getAsync(null)
            ])
            .spread(function(self, sync, local){
                // we check if the application have been updated
                var update = versionDiff(self.version, sync.version);
                // we remove the version from the sync variable to avoid
                // confusion between self.version and sync.version
                delete sync.version;
                // we store the new version number in storage
                chrome.storage.sync.setAsync({'version':self.version});

                var settings = {
                    self: self,
                    sync: sync,
                    local: local
                };

                if(update)
                    settings.update = update;

                return settings;
            });
        },

        set: function(newSettings, options){
            var options = options || { area: "sync", override: false};

            // strip angular $$hashKey properties
            newSettings = JSON.parse(angular.toJson(newSettings));

            // if override we clear and write the new settings
            if(options.override)
                return chrome.storage[options.area].clearAsync()
                .then(function(){
                    return chrome.storage[options.area].setAsync(newSettings);
                });

            else
                return chrome.storage[options.area].setAsync(newSettings);

            // // Otherwise we compute the difference with the current Settings
            // // see https://github.com/flitbit/diff
            // return chrome.storage[options.area].getAsync(null)
            // .then(function(currentSettings){
            //     // strip angular $$hashKey properties
            //     currentSettings = JSON.parse(angular.toJson(currentSettings));
            //
            //     var jsDiff = jsondiffpatch.create({
            //         // used to match objects when diffing arrays, by default only === operator is used
            //         objectHash: function(obj) {
            //             // this function is used only to when objects are not equal by ref
            //             return obj.name;
            //         },
            //         arrays: {
            //             // default true, detect items moved inside the array (otherwise they will be registered as remove+add)
            //             detectMove: true,
            //             // default false, the value of items moved is not included in deltas
            //             includeValueOnMove: false
            //         },
            //         textDiff: {
            //             // default 60, minimum string length (left and right sides) to use text diff algorythm: google-diff-match-patch
            //             minLength: 60
            //         }
            //     });
            //
            //     var userSettingsDiffFilter = function(context) {
            //         // console.log(context);
            //         if(context.childname == "enabled")
            //             context.exit();
            //         // if (typeof context.left === 'number' && typeof context.right === 'number') {
            //             // context.setResult([0, context.right - context.left, NUMERIC_DIFFERENCE]).exit();
            //         // }
            //     };
            //     userSettingsDiffFilter.filterName = 'userSettings';
            //     console.log(jsDiff.processor.pipes.diff.list());
            //
            //     // insert my new filter, right before trivial one
            //     jsDiff.processor.pipes.diff.before('dates', userSettingsDiffFilter);
            //
            //     // for debugging, log each filter
            //     // jsDiff.processor.pipes.diff.debug = true;
            //
            //
            //     var delta = jsDiff.diff(newSettings, currentSettings);
            //     console.log(delta);
            //
            //     jsDiff.patch(currentSettings, delta);
            //     console.log(currentSettings);
            //
            // });

        }
    }
}]);

angular.module('cardboard.directives',[]);

angular.module('cardboard.directives')

.directive('myTyper',[
    '$interval',
    '$timeout',
    function($interval, $timeout){
    return {
        scope: {
            source: "=",
            delay: "=",
            start: "=",
            wipeDelay: "=",
            term: "=",
            callbackFn: "&"
        },
        link: function(scope, element, attrs){
            var delay = attrs.delay || 150,
                wipeDelay = attrs.wipeDelay || 2500,
                callbackFn = scope.callbackFn || angular.noop,
                // loop = ("loop" in attrs && attrs.loop !=="false") || false,
                cursor = 0,
                chain,
                cancel;

                // implementation of a blinker cursor (not optimized)
                // element.html('<span></span><i style="font-style:normal; -webkit-animation: blink-it steps(1) 1s infinite;">|</i>');


                // We watch the 'start' expression to kick off the promise chain
                // or cancel it
                scope.$watch('start', function(start){
                    cancel = !start;
                    if(start){
                        parse(scope.source)
                        // When everything is done we call the callback
                        .then(callbackFn)
                        .catch(function(error){
                            // Callback for a canceled promise chain. Typically
                            // when 'start' changes and evaluates to false
                            return error;
                        });
                    }
                    else
                        wipe(0);
                });

                function parse(source){
                    // We iterate sequentially through the array or promise of an array
                    return Promise.each(source, function(str, index, value){
                        if(attrs.term)
                            scope.$apply(function(){scope.term = str;});
                        // Write each word
                        return write(str)
                        .then(function(){
                            // don't wipe if it's the last one
                            if(index < value-1)
                                return wipe(wipeDelay);
                            return;
                        });

                    });
                }

                function write(str){
                    // We loop through each char at a given interval delay
                    chain = $interval(function(){
                        // if user cancel we wipe immediately
                        // and cancel the $interval to prevent memory leaks
                        if(cancel){
                            wipe(0);
                            $interval.cancel(chain);
                        }
                        else{
                            // element.find('span').text(element.find('span').text()+str.charAt(cursor));
                            element.text(element.text() + str.charAt(cursor));
                            cursor++;
                        }
                    }, delay, str.length)

                    return chain;
                }

                function wipe(timeout){
                    // We reset the cursor when a word is done writing
                    return $timeout(function(){
                        // element.find('span').text("");
                        element.text("");
                        cursor = 0;
                    }, timeout)
                }

                // Cancel the interval on element destroy to save memory leaks
                element.on('$destroy', function() {
                    $interval.cancel(chain);
                });

        }
    }
}]);

angular.module('cardboard.directives')

.directive('myProgressBar', [
    '$interval',
    '$timeout',
    function($interval, $timeout) {
    return {
        restrict: 'E',
        scope:{
            progress: '&',
            monitor: '=',
            relative: '='
        },
        template: '<div class="progress"><div class="determinate" style="transition: transform .5s ease-in-out; width: 100%; overflow: hidden; transform: translateX(-100%);"></div></div>',
        link: function(scope, element, attrs) {
            var monitor = parseInt(attrs.monitor) || 1000,
                relative = ("relative" in attrs && attrs.relative !=="false") || false;

            var previous;

            // update progress once
            scope.progress().then(function(current){
                updateBar(current);
            });

            // if monitor attribute is defined we repeat the functions with the
            // given interval delay
            if(typeof attrs.monitor !== 'undefined')
                var interval = $interval(function(){
                    scope.progress().then(function(current){
                        updateBar(current);
                    });
                }, monitor);


            function updateBar(current){
                var percent = 0;

                if(relative && previous && (current.total != previous.total))
                    percent = Math.floor((current.progress-previous.progress)/ (current.total-previous.total) *100);
                else
                    percent = Math.floor(current.progress*100/current.total);

                previous = current;

                element.children().children().css('transform','translateX(-'+(100-percent)+'%)');
            }

            // Cancel the interval on element destroy to save memory leaks
            element.on('$destroy', function() {
                $interval.cancel(interval);
            });
        }
    };
}]);

angular.module('cardboard.directives')

.directive('myPieDownloader', [
    '$interval',
    '$timeout',
    function($interval, $timeout) {
    return {
        scope:{
            stream: "="
        },
        link: function(scope, elem, attrs) {

            // create the canvas and appends it in the element
            var canvas = document.createElement('canvas');
            var savedIconUrl = scope.stream.iconUrl;
            canvas.width = canvas.height = 38;
            elem.prepend(canvas);
            var ctx = canvas.getContext('2d');

            Math.TAU = 2 * Math.PI;

            // Draw one time the progression
            drawProgressSpinner(ctx, (scope.stream.bytesReceived / scope.stream.totalBytes));
            // update the progression each 1000ms
            var timeoutId = $interval(pollProgress,1000,0,false);
            // cancel the timeout on element destroy to save memory leaks
            elem.on('$destroy', function() {
                $interval.cancel(timeoutId);
            });


            function pollProgress(){
                if(scope.stream.state == "in_progress" && !scope.stream.paused)
                    chrome.downloads.searchAsync({id:scope.stream.id})
                    .then(function(dl){
                        // update received bytes and estimated time at each iteration
                        scope.stream.bytesReceived = dl[0].bytesReceived;
                        scope.stream.totalBytes = dl[0].totalBytes;
                        scope.stream.estimatedEndTime = dl[0].estimatedEndTime;

                        drawProgressSpinner(ctx, (scope.stream.bytesReceived / scope.stream.totalBytes));
                        scope.$apply();
                    });
            }

            function drawProgressSpinner(ctx, stage) {
                ctx.fillStyle = ctx.strokeStyle = "#4db6ac";

                var clocktop = -Math.TAU/4;
                drawProgressArc(ctx, clocktop, clocktop + (stage * Math.TAU));
            }

            function drawProgressArc(ctx, startAngle, endAngle) {
                var center = ctx.canvas.width/2;
                ctx.lineWidth = Math.round(ctx.canvas.width*0.1);
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.arc(center, center, center * 0.9, startAngle, endAngle, false);
                ctx.fill();
            }

        }
    };
}]);

angular.module('cardboard.directives')

.directive('myCtrlClick',[
    function(){
    return{
        restrict: 'A',
        scope: {
            url: '=',
            beforeClick: '&'
        },
        link: function(scope, element, attrs){
            var beforeClick = scope.beforeClick || angular.noop;

            element.bind('click', function(event){
                beforeClick();

                if(scope.url){
                    // in background tab if ctrl or cmd key is held
                    if(event.ctrlKey || event.metaKey || event.which == 2)
                        chrome.tabs.create({
                            url: scope.url,
                            active: false
                        });
                    // in current tab otherwise
                    else
                        chrome.tabs.update({
                            url: scope.url
                        });
                }
            });
        }
    }
}]);

angular.module('cardboard.directives')

.directive('myBgPick', [
    '$q',
    function($q) {
    return {
        restrict: 'E',
        replace: true,
        template: '<input type="file" accept="image/png, image/jpeg, image/webp"/>',
        link: function(scope, elem, attrs) {

            elem.bind('change', function(input) {

                if (input.target.files && input.target.files[0]) {
                    var reader = new FileReader();

                    // read file
                    reader.readAsDataURL(input.target.files[0]);

                    // create a promise for when file reading is done
                    var deferred = $q.defer();
                    scope.backgroundFromDevice = deferred.promise;
                    reader.onload = function(e){
                        // resolve the promise with file data
                        deferred.resolve({
                            filename: input.target.value.replace("C:\\fakepath\\",""),
                            dataUrl: e.target.result
                        });
                    };
                }
            });
        }
    };
}]);

angular.module('cardboard.controllers',[]);

angular.module('cardboard.controllers')

.controller('TopSitesCtrl', [
    '$scope',
    function($scope){
    $scope.maxTopSites = 5;

    chrome.topSites.getAsync().then(function(topSites){
        $scope.$apply(function(){
            $scope.topSites = topSites;
        });
        $scope.initDropdowns('.card.topsites .dropdown-card-btn');
    });
}]);

angular.module('cardboard.controllers')

.controller('SystemCtrl', [
    '$scope',
    function($scope){

    chrome.system.cpu.getInfoAsync().then(function(cpu){
        $scope.$apply(function(){
            $scope.cpu = cpu;
        });
        $scope.initDropdowns('.card.system .dropdown-card-btn');
    });

    chrome.system.memory.getInfoAsync().then(function(memory){
        $scope.$apply(function(){
            $scope.memory = memory;
        });
    });

    chrome.system.storage.getInfoAsync().then(function(storage){
        $scope.$apply(function(){
            $scope.storage = storage;
        });
    });

    chrome.system.storage.onAttached.addListener(function(storage){
        $scope.storage.push(storage);
        $scope.$apply();
    });

    chrome.system.storage.onDetached.addListener(function(storageId){
        for(var i in $scope.storage)
            if($scope.storage[i].id == storageId)
                $scope.storage.splice(i,1);

        $scope.$apply();
    });

    $scope.getCpuLoad = function(cpuIndex){
        return chrome.system.cpu.getInfoAsync().then(function(cpu){
            return {
                progress: cpu.processors[cpuIndex].usage.kernel +
                         cpu.processors[cpuIndex].usage.user,
                total: cpu.processors[cpuIndex].usage.total
            };
        });
    };

    $scope.getMemoryLoad = function(){
        return chrome.system.memory.getInfoAsync().then(function(memory){
            $scope.memory = memory;
            return {
                progress: memory.capacity - memory.availableCapacity,
                total: memory.capacity
            };
        });
    };
}]);

angular.module('cardboard.controllers')

.controller('SettingsCtrl',[
    '$scope',
    '$q',
    '$timeout',
    function($scope, $q, $timeout){

    // Animate the setting container
    $timeout(function(){
        $scope.settingsViewTimeout = true;
    }, 200);

    $scope.save = function(storageKey, value){
        var toSave = {};
        toSave[storageKey] = value;
        chrome.storage.sync.setAsync(toSave);
    };

    service.getConfig().addCallback(function(config){
        $scope.analytics = config.isTrackingPermitted();
    });
    $scope.toggleAnalytics = function(){
        service.getConfig().addCallback(function(config) {
            config.setTrackingPermitted($scope.analytics);
        });
    };

    $scope.saveBackgroundFromDevice = function(){
        // backgroundFromDevice is defined into <bg-pick> (directive)
        if(!this.backgroundFromDevice)
            toast("no file selected", 4000);
        else
            this.backgroundFromDevice.then(function(bg){
                $scope.track('Background', 'Saved', 'From Device');
                $scope.backgroundSave({
                    name: bg.filename,
                    type: "Local",
                    url: bg.dataUrl
                });
            });
    };

    $scope.saveBackgroundFromUrl = function(){
        // backgroundFromUrl is defined via ng-model (view)
        if(!this.backgroundFromUrl)
            toast("invalid URL", 4000);
        else{
            $scope.track('Background', 'Saved', 'From URL');
            $scope.backgroundSave({
                name: this.backgroundFromUrl.substring(this.backgroundFromUrl.lastIndexOf('/')+1),
                type: "URL",
                url: this.backgroundFromUrl
            });
        }
    };

    $scope.openUrl = function(){
        $('#modalBgUrl').openModal();
    };

    $scope.openLocal = function(){
        $('#modalBgDevice').openModal();
    };

    $scope.backgroundSave = function(bg){
        var bgIndex = $scope.$parent.backgrounds.length;

        // identify previous background (url or local)
        for(var i=0; i<$scope.$parent.backgrounds.length; i++)
            if($scope.$parent.backgrounds[i].type == bg.type && $scope.$parent.backgrounds[i].url){
                bgIndex = i;
                break;
            }

        // Add the determinded id
        bg.id = bgIndex;
        // Update the scope (add the new background in the list)
        $scope.$parent.backgrounds[bgIndex] = bg;
        $scope.$parent.background = bg;
        $scope.$parent.backgroundId = bgIndex;
        $scope.$parent.setBackground(bg);

        // Create a copy of $scope.$parent.backgrounds
        var bgs = JSON.parse(JSON.stringify($scope.$parent.backgrounds));

        // Save the background dataUrl to the cache
        if(bg.type == "Local")
            chrome.storage.local.setAsync({"localBackgroundDataUrl": bg.url});

        // Remove dataUrl because it's too big to fit sync storage
        for(var i in bgs)
            if(bgs[i].type == "Local")
                bgs[i].url = true;

        chrome.storage.sync.setAsync({
            'backgrounds': bgs,
            'backgroundId': bg.id
        });
    };
}]);

angular.module('cardboard.controllers')

.controller('SessionsCtrl', [
    '$scope',
    function($scope){
    $scope.maxDevices = 5;
    $scope.maxDeviceTabs = 5;
    $scope.maxRecentlyClosed = 5;

    var willGetRecentlyClosed = chrome.sessions.getRecentlyClosedAsync({
        maxResults: $scope.maxRecentlyClosed
    }).then(function(recentlyClosed){
        $scope.recentlyClosed = mergeTabsAndWindows(recentlyClosed);
    });

    var willGetDevices = chrome.sessions.getDevicesAsync({
        maxResults: $scope.maxDevices
    }).then(function(devices){
        for(var d in devices)
            devices[d]['tabs'] = mergeTabsAndWindows(devices[d].sessions);
        $scope.devices = devices;
    });


    Promise.all([willGetDevices, willGetRecentlyClosed])
    .then(function(){
        $scope.$apply();
        $scope.initDropdowns('.card.sessions .dropdown-card-btn');
        $('.card.sessions .tabs').tabs();
        // dirty fix for the tab indicator to display at correct size
        setTimeout(function () {
            $('.card.sessions .tabs').tabs('select_tab', 'tab-content-recent');
        }, 250);
    });

    // Return an array of tabs wether the input object contains tabs
    // or windows of tabs
    function mergeTabsAndWindows(sessionItem){
        var tabs = [];
        for(var i in sessionItem){
            // If it's a tab we push it with lastModified value
            if(sessionItem[i].tab){
                var tab = sessionItem[i].tab;
                tab['lastModified'] = moment.unix(sessionItem[i].lastModified);
                tabs.push(tab);
            }
            // If it's a window we gather each tab and add them to the others
            // e.g: we don't care about the difference between tabs and windows
            else if(sessionItem[i].window){
                for(var j in sessionItem[i].window.tabs){
                    var tab = sessionItem[i].window.tabs[j];
                    tab['lastModified'] = moment.unix(sessionItem[i].lastModified);
                    tabs.push(tab);
                }
            }
        }
        return tabs;
    }

}]);

angular.module('cardboard.controllers')

.controller('RootCtrl',[
    '$scope',
    '$location',
    '$http',
    '$timeout',
    'DefaultSettings',
    'ChromePermissions',
    'ChromeSettings',
    'TrendsFactory',
    function($scope, $location, $http, $timeout, DefaultSettings, Permissions, Settings, Trends){

    // we gather all the settings
    $scope.settings = Settings.get().then(function(settings){
        if(settings.update == "major"){
            settings.sync = DefaultSettings;
            Settings.set(DefaultSettings);
        }
        return settings;
    });

    // then we init background and trends with it
    $scope.settings.then(function(settings){

        // Init trends
        $scope.trends = settings.sync.trends;
        $scope.trends.data = Trends.get();
        $scope.trends.start = true;

        // If local background (dataURl) we get it from cache
        for(var i in settings.sync.backgrounds)
            if(settings.sync.backgrounds[i].type == "Local" && settings.sync.backgrounds[i].url)
                settings.sync.backgrounds[i].url = settings.local.localBackgroundDataUrl;

        $scope.backgrounds = settings.sync.backgrounds;
        $scope.background = settings.sync.backgrounds[settings.sync.backgroundId];
        $scope.setBackground($scope.background);

        // if it's a new install we redirect to the onboarding page
        if(settings.update == "major")
            $location.path("onboarding");
    });

    $scope.searchTrend = function(){
        return 'https://google.com/search?q='+encodeURI($scope.trendTerm);
    };

    $scope.setBackground = function(background){
        // check background property exists to avoid errors due to promise not
        // beeing resolved yet
        if(background.type == "Google Now")
            $scope.backgroundImageUrl = getBackgroundTime(background.url);
        else
            $scope.backgroundImageUrl = background.url;
    };

    $scope.wipe = function(){
        $scope.wipeRipple = true;
        $timeout(function(){
            $scope.wipeRipple = false;
        }, 1300);
    };

    function getBackgroundTime(url){
        var date = new Date;
        date.setTime(date);
        var hour = date.getHours();
        var time;

        if (hour>5 && hour<8)
            time = url.dawn;
        else if (hour>8 && hour<19)
            time = url.day;
        else if (hour>19 && hour<21)
            time = url.dusk;
        else
            time = url.night;
        return time;
    }

    /********* USEFUL STUFF **********/

    $scope.getFavicon = function(url){
        return DefaultSettings.faviconURL + encodeURI(url);
    };

    $scope.initDropdowns = function(selector){
        $(selector).dropdown({
            inDuration: 300,
            outDuration: 225,
            constrain_width: false, // Does not change width of dropdown to that of the activator
            hover: false, // Activate on click
            alignment: 'right', // Aligns dropdown to left or right edge (works with constrain_width)
            gutter: 0 // Spacing from edge
        });
    };

    // Allows views to know in which route they are
    $scope.route = function(){
        return $location.path();
    };

    $scope.goTo = function(url){
        chrome.tabs.update({url:url});
    };

    $scope.track = function(category, action, label, value){
        tracker.sendEvent(category, action, label, value);
    };
}]);

angular.module('cardboard.controllers')

.controller('QuickSettingsCtrl', [
    '$rootScope',
    '$scope',
    function($rootScope, $scope){

    $scope.clearTypes = {
        "cache": false,
        "cookies": false,
        "history": false,
        "localStorage": false,
    };
    $scope.initDropdowns('.card.quicksettings .dropdown-card-btn');

    function isAllFalse(object){
        for (var key in object)
            if (object.hasOwnProperty(key))
                if(object[key] !== false)
                    return false;
        return true;
    }

    $scope.clearDisabled = function(){
        return $scope.isClearing || isAllFalse($scope.clearTypes);
    }

    $scope.clearText = "Clear";
    $scope.isClearing = false;
    $scope.waveTimeout = true;

    $scope.clear = function(){
        // forbid spamming button immediately
        if(!$scope.clearDisabled()){
            // general progress bar
            $rootScope.loading = true;
            $scope.waveTimeout = false;
            $scope.isClearing = true;

            // wait 500ms until the wave animation ends before disabing it
            Promise.delay(500)
            .then(function(){
                if($scope.isClearing)
                    $scope.clearText = "Clearing";
                $scope.waveTimeout = true;
                $scope.$apply();
            });

            chrome.browsingData.removeAsync({since: 0},$scope.clearTypes)
            // Promise.delay(3000) //mocks
            .then(function(){
                // completed
                $rootScope.loading = false;
                $scope.clearText = "Clear";
                $scope.isClearing = false;
                $scope.waveTimeout = true;
                $scope.$apply();
                toast("Cleared !", 4000);
            });

        }
    }
}]);

angular.module('cardboard.controllers')

.controller('HistoryCtrl', [
    '$scope',
    function($scope){
    $scope.maxHistory = 5;

    chrome.history.searchAsync({
        text: "", // empty for all pages
        maxResults: $scope.maxHistory
    }).then(function(history){
        $scope.$apply(function(){
            $scope.history = history;
        });
        $scope.initDropdowns('.card.history .dropdown-card-btn');
    });
}]);

angular.module('cardboard.controllers')

.controller('FeedCtrl',[
    '$scope',
    '$timeout',
    'ChromePermissions',
    'ChromeSettings',
    function($scope, $timeout, Permissions, Settings){

    $scope.isDrag = false;

    // Prevent the FAB from flashing due to value beeing brievly undefined
    $scope.allCardsEnabled = true;

    $scope.settings.then(function(settings){

        // init welcome messages
        $scope.dailyMsg = settings.sync.welcomeMessages[Math.floor((Math.random() * settings.sync.welcomeMessages.length))];

        // init cards
        return Promise.map(settings.sync.cards, function(card){
            // if cardboard installed or updated we show the changelog
            if(settings.update && settings.update != "patch" && card.name == 'changelog' && ($scope.route()=='/feed') )
                card.enabled = true;

            // if the card has permission we check for them before
            if(card.permissions)
                return Permissions.contains({permissions: card.permissions})
                .then(function(permissions){
                    // if a permission is denied we can't enable the card
                    // Disable the card if not granted AND enabled
                    card.enabled = (!permissions.denied && card.enabled);
                    return card;
                });
            else
                return card;
        });
    })
    .then(function(cards){
        // we save the init state
        Settings.set({'cards':cards});

        $scope.$apply(function(){
            $scope.cards = cards;
        });
        checkCardsEnabled();
        checkCardsDisabled();
    });


    // see http://packery.metafizzy.co/faq.html#order-after-drag
    // and http://packery.metafizzy.co/methods.html#packery-data
    // var pckryElement = document.querySelector('#feed > div');
    // var pckry = Packery.data(pckryElement);

    $scope.toggle = function(card, on){
        var self = this;
        if(typeof on === "undefined")
            on = card.enabled;

        if(on)
            Permissions.request({permissions: card.permissions})
            .then(function(){
                // Granted
                tracker.sendEvent('Card', 'Granted', card.name);
                enable(card);
            })
            .catch(function(){
                // Denied, we don't enable the card
                tracker.sendEvent('Card', 'Denied', card.name);
                disable(card);
                toast("Card needs permission to run", 4000);
            });
        else
            Permissions.remove({permissions: card.permissions})
            .then(function(){
                tracker.sendEvent('Card', 'Removed', card.name);
                disable(card);
            });
    };

    function enable(card){
        $scope.$apply(function(){
            card.enabled = true;
            // We know all cards are not disabled, we just enabled one
            $scope.allCardsDisabled = false;
        });
        checkCardsEnabled();
        Settings.set({'cards':$scope.cards});
    }
    function disable(card){
        $scope.$apply(function(){
            card.enabled = false;
            // We know all cards are not enabled, we just disabled one
            if(!card.system)
                $scope.allCardsEnabled = false;
        });
        checkCardsDisabled();
        Settings.set({'cards':$scope.cards});
    }

    function checkCardsEnabled(){
        if($scope.cards)
            for(var i=0; i<$scope.cards.length; i++){
                if(!$scope.cards[i].enabled && !$scope.cards[i].system){
                    $scope.$apply(function(){$scope.allCardsEnabled = false;});
                    break;
                }
                else if(i == $scope.cards.length-1)
                    $scope.$apply(function(){$scope.allCardsEnabled = true;});
            }
    }
    function checkCardsDisabled(){
        if($scope.cards)
            for(var i=0; i<$scope.cards.length; i++){
                if($scope.cards[i].enabled){
                    $scope.$apply(function(){$scope.allCardsDisabled = false;});
                    break;
                }
                else if(i == $scope.cards.length-1)
                    $scope.$apply(function(){$scope.allCardsDisabled = true;});
            }
    }

    /********* ONBOARDING **********/

    $timeout(function(){
        $scope.nextCard = 0;
    }, 200);

    $scope.next = function(){
        $scope.nextCard++;
    };

    /********* FAB STUFF **********/

    var fab = $('.fixed-action-btn');
    fab.off( "mouseenter mouseleave" ); // Disable FAB on hover

    $('.fixed-action-btn').mouseleave(fabOff);

    $scope.triggerFab = function(){
        if($scope.fab)
            fabOff();
        else
            fabOn();
    };

    function fabOn(){
        var time = 0;
        fab.children('ul').css('display','block');
        fab.find('ul a.btn-floating').reverse().each(function () {
            $(this).velocity(
                { opacity: "1", scaleX: "1", scaleY: "1", translateY: "0"},
                { duration: 100, delay: time });
            time += 40;
        });
        $scope.fab = true;
    }

    function fabOff(){
        var time = 0;
        fab.find('ul a.btn-floating').velocity("stop", true);
        fab.find('ul a.btn-floating').velocity(
            { opacity: "0", scaleX: ".4", scaleY: ".4", translateY: "40px"},
            {
                duration: 100,
                complete: function(){
                    setTimeout(function () {
                        fab.children('ul').css('display','none');
                    }, 50);
                }
            });

        $scope.fab = false;
    }

}]);

angular.module('cardboard.controllers')

.controller('DownloadCtrl', [
    '$scope',
    'fromNowFilter',
    'humanizeFilter',
    function($scope, fromNow, humanize){
    $scope.downloads = [];

    // get recent Downloads
    chrome.downloads.searchAsync({limit: 15, orderBy: ['-startTime']})
    .map(function(download, index, arrayLength){
        // Avoid a case where fetching icons with no filename throws an error
        if(download.filename){
            // fetch their icon
            return chrome.downloads.getFileIconAsync(download.id)
            .then(function(dataUrl){
                download.icon = dataUrl;
                return download;
            });
        }
        else
            return download;
    })
    .then(function(downloads){
        $scope.downloads = downloads;
        $scope.$apply();
        // init all dropdowns
        $scope.initDropdowns('.card.downloads .dropdown-card-btn');
        $scope.initDropdowns('.card.downloads .download .more');
    });

    // Watch changes in download states and apply them to the model
    chrome.downloads.onChanged.addListener(function(downloadDelta){
        for (i in $scope.downloads)
            if($scope.downloads[i].id == downloadDelta.id){
                for (j in downloadDelta)
                    if(j != "id")
                        $scope.downloads[i][j] = downloadDelta[j].current;
                break;
            }

        $scope.$apply();
    });

    // Watch if a download is created and add it to the card
    chrome.downloads.onCreated.addListener(function(download){
        $scope.downloads.pop(); // remove the last element
        $scope.downloads.unshift(download); // add the newly created at the beggining

        // wait 500ms after download starts to get the icon
        Promise.delay(500).then(function(){
            // Avoid a case where fetching icons with no filename throws an error
            if(download.filename)
                return chrome.downloads.getFileIconAsync(download.id);
            else
                throw new Error("No filename");
        })
        .then(function(dataUrl){
            for(var i in $scope.downloads)
                if($scope.downloads[i].id == download.id){
                    $scope.downloads[i].icon = dataUrl;
                    break;
                }
            // Should init the new new dropdown but doesn't work
            // $scope.initDropdowns('#dropdown-'+download.id);
        })
        .finally(function(){$scope.$apply();});
    });

    $scope.open = function(){
        if(this.download.state == "interrupted")
            toast(humanize(this.download.error), 4000);
        else if(this.download.state == "complete"){
            if(this.download.exists)
                chrome.downloads.open(this.download.id);
            else
                toast("File moved or deleted", 4000);
        }
    };
    $scope.resume = function(){
        chrome.downloads.resumeAsync(this.download.id);
    };
    $scope.pause = function(){
        chrome.downloads.pauseAsync(this.download.id);
    };
    $scope.cancel = function(){
        chrome.downloads.cancelAsync(this.download.id);
    };
    $scope.retry = function(){
        chrome.downloads.downloadAsync({url: this.download.url});
    };
    $scope.remove = function(){
        chrome.downloads.eraseAsync({id: this.download.id})
        .then(function(erased){
            for(var i in $scope.downloads)
                if($scope.downloads[i].id == erased[0]){
                    $scope.downloads.splice(i, 1);
                    break;
                }
            $scope.$apply();
        });
    };
    $scope.show = function(){
        chrome.downloads.show(this.download.id);
    };

    $scope.getStatus = function(){
        var str;

        if(this.download.state == "in_progress"){
            if(this.download.paused)
                str = "Paused";
            else
                str = fromNow(this.download.estimatedEndTime);
        }
        else if(this.download.state == "interrupted"){
            str = humanize(this.download.error);
        }
        else if(this.download.state == "complete"){
            str = fromNow(this.download.endTime);
        }
        return str;
    };

}]);

angular.module('cardboard.controllers')

.controller('ChangelogCtrl', [
    '$scope',
    function($scope){
    $scope.settings.then(function(settings){
        $scope.version = settings.self.version;
    });
}]);

angular.module('cardboard.controllers')

.controller('BookmarkCtrl', [
    '$scope',
    function($scope){
    // init tabs
    $('.card.bookmarks .tabs').tabs();
    $('.card.bookmarks .tabs').tabs('select_tab', 'recent-bookmarks');

    chrome.bookmarks.getRecentAsync(5).then(function(recents){
        $scope.$apply(function(){
            $scope.recents = recents;
        });
        $scope.initDropdowns('.card.bookmarks .dropdown-card-btn');
    });

    // get root bookmarks
    chrome.bookmarks.getChildrenAsync("0").then(function(root){
        $scope.$apply(function(){
            $scope.tree = root;
        });
    });

    $scope.getChildren = function(id){
        chrome.bookmarks.getChildrenAsync(id).then(function(children){
            if(children.length > 0){
                $scope.tree = children;
                return chrome.bookmarks.getAsync(children[0].parentId);
            }
            else
                return Promise.reject("Empty");
        })
        .then(function(parent){
            $scope.parentNode = parent[0];
            $scope.$apply();
        })
        .catch(function(error){
            toast(error, 4000);
        });
    };
}]);

angular.module('cardboard.controllers')

.controller('AppCtrl', [
    '$scope',
    function($scope){
    $scope.apps = [];
    $scope.extensions = [];
    $scope.themes = [];

    chrome.management.getAllAsync()
    .then(function(all){
        angular.forEach(all, function(value, key){
            if(value.type == "extension")
                $scope.extensions.push(value);
            else if (value.type == "theme")
                $scope.themes.push(value);
            else if(value.enabled){
                if($scope.$parent.card.settings && $scope.$parent.card.settings[value.id])
                    value.frequency = $scope.$parent.card.settings[value.id].frequency;
                else
                    value.frequency = 0;

                $scope.apps.push(value);
            }
        });
        $scope.$apply();
        $scope.initDropdowns('.card.apps .dropdown-card-btn');
        $('.card.apps .tooltipped').tooltip({delay: 1000});
    });

    $scope.launch = function(){
        if(this.app.launchType == "OPEN_AS_WINDOW")
            chrome.management.launchApp(this.app.id);
    }

    $scope.getIcon = function(){
        var icon_url;
        if(this.app.icons)
            icon_url = this.app.icons[this.app.icons.length-1].url;
        else
            icon_url = "chrome://extension-icon/khopmbdjffemhegeeobelklnbglcdgfh/256/1";
        if(!this.app.enabled)
            icon_url+="?grayscale=true";
        return icon_url;
    };

    $scope.updateFrequency = function(){
        if(!$scope.$parent.card.settings)
            $scope.$parent.card.settings = {};

        // If frequency not defined we put 1 else we increment it
        if(!$scope.$parent.card.settings[this.app.id])
            $scope.$parent.card.settings[this.app.id] = {'frequency': 1};
        else if($scope.$parent.card.settings[this.app.id].frequency)
            $scope.$parent.card.settings[this.app.id] = {'frequency': $scope.$parent.card.settings[this.app.id].frequency+1};

        // We don't update scope to avoid suddenly changing apps position after click

        // We save frequency in storage
        chrome.storage.sync.setAsync({'cards': $scope.$parent.cards});
    };

}]);

// Chrome Platform Analytics
var service = analytics.getService('Cardboard');
var tracker = service.getTracker('UA-60245585-4');

angular.module('cardboard', [
	'ngRoute',
	'ngAnimate',
	'ngChromePermissions',
	'angular-packery',
	'cardboard.controllers',
	'cardboard.factories',
	'cardboard.directives',
	'cardboard.filters'
])

.config([
	'$routeProvider',
	'$compileProvider',
	function($routeProvider, $compileProvider) {
	$routeProvider
	.when('/feed', {
		controller: 'FeedCtrl',
		templateUrl: 'src/templates/Feed.html'
	})
	.when('/settings', {
		controller: 'SettingsCtrl',
		templateUrl: 'src/templates/Settings.html'
	})
	.when('/onboarding', {
		controller: 'FeedCtrl',
		templateUrl: 'src/templates/Onboarding.html'
	})
	.otherwise({ redirectTo: '/feed'});

	// sanitize urls from chrome-extension
	$compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|chrome-extension):/);
}])

.run([
	'$rootScope',
	'$location',
	function($rootScope, $location){
	// Track route changes
	$rootScope.$on('$routeChangeSuccess', function() {
		var path = $location.path();
		tracker.sendAppView(path.substring(1));
	});
}])

.value('DefaultSettings',{
	welcomeMessages: [
        "Hey, how's your day?",
        "Hope you're doing well",
        "Someone think of you ;)",
        "Hello !",
        "Try smiling, it works !",
        "Did you know you rock ?",
        "Let's get motivated shall we ?",
        "Come on buddy, you can be whoever you want"
    ],

	// imgur album: https://imgur.com/a/NAaUE
	backgrounds: [
		{
			id: 0,
			name: "Austin",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/7ndeJog.png",
				day: "https://i.imgur.com/FsJ8mCW.png",
				dusk: "https://i.imgur.com/Mmwv5GQ.png",
				night: "https://i.imgur.com/brJBKA3.png"
			}
		},
		{
			id: 1,
			name: "Beach",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/Q5Tn8u9.png",
				day: "https://i.imgur.com/dTFXUxt.png",
				dusk: "https://i.imgur.com/vdO9Ote.png",
				night: "https://i.imgur.com/YaoPX9P.png"
			}
		},
		{
			id: 2,
			name: "Berlin",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/jG1OdPc.png",
				day: "https://i.imgur.com/lnILrRU.png",
				dusk: "https://i.imgur.com/ZCJVfSn.png",
				night: "https://i.imgur.com/5mN7Iau.png"
			}
		},
		{
			id: 3,
			name: "Chicago",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/f4HUPlZ.png",
				day: "https://i.imgur.com/t5wzT8j.png",
				dusk: "https://i.imgur.com/XrJi3O1.png",
				night: "https://i.imgur.com/xDWHJ45.png"
			}
		},
		{
			id: 4,
			name: "Default",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/kJFNQLr.png",
				day: "https://i.imgur.com/foVYQ6T.png",
				dusk: "https://i.imgur.com/dW217U5.png",
				night: "https://i.imgur.com/87UObPk.png"
			}
		},
		{
			id: 5,
			name: "Great Plains",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/dWzcGbr.png",
				day: "https://i.imgur.com/huGlyp2.png",
				dusk: "https://i.imgur.com/XNUMKAT.png",
				night: "https://i.imgur.com/d7KaqQ1.png"
			}
		},
		{
			id: 6,
			name: "London",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/ZD0XBoz.jpg",
				day: "https://i.imgur.com/C2Sg6JG.jpg",
				dusk: "https://i.imgur.com/Qb8PHnA.jpg",
				night: "https://i.imgur.com/k0idCJG.jpg"
			}
		},
		{
			id: 7,
			name: "New York",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/JVK8ID7.png",
				day: "https://i.imgur.com/yB93g10.png",
				dusk: "https://i.imgur.com/z4elpiG.png",
				night: "https://i.imgur.com/lh0LV5L.png"
			}
		},
		{
			id: 8,
			name: "Paris",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/c3wAjp2.png",
				day: "https://i.imgur.com/c3wAjp2.png",
				dusk: "https://i.imgur.com/vmfdH9T.png",
				night: "https://i.imgur.com/vmfdH9T.png"
			}
		},
		{
			id: 9,
			name: "San Francisco",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/fqewVsW.png",
				day: "https://i.imgur.com/lUZp177.png",
				dusk: "https://i.imgur.com/XP6Omxa.png",
				night: "https://i.imgur.com/NATsgio.png"
			}
		},
		{
			id: 10,
			name: "Seattle",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/7nsrzRK.jpg",
				day: "https://i.imgur.com/0E2xXb0.jpg",
				dusk: "https://i.imgur.com/wYytDhF.jpg",
				night: "https://i.imgur.com/ddI0eBh.jpg"
			}
		},
		{
			id: 11,
			name: "Tahoe",
			type: "Google Now",
			url: {
				dawn: "https://i.imgur.com/ZSXPIkL.jpg",
				day: "https://i.imgur.com/xeVYGPU.jpg",
				dusk: "https://i.imgur.com/Buxx2Cs.jpg",
				night: "https://i.imgur.com/g761v2t.jpg"
			}
		}
	],
	backgroundId: 4,
	trends: {
		url: "https://hawttrends.appspot.com/api/terms/",
		enabled: true
	},
	cards: [
		{
			name: "apps",
			enabled: false,
			template: "src/templates/cards/AppCard.html",
			icon: "mdi-navigation-apps",
			permissions: ["management"]
		},
		{
			name: "bookmarks",
			enabled: false,
			template: "src/templates/cards/BookmarkCard.html",
			icon: "mdi-action-bookmark",
			permissions: ["bookmarks"]
		},
		{
			name: "quick_settings",
			enabled: false,
			template: "src/templates/cards/QuickSettingsCard.html",
			icon: "mdi-action-settings",
			permissions: ["browsingData"]
		},
		{
			name: "downloads",
			enabled: false,
			template: "src/templates/cards/DownloadCard.html",
			icon: "mdi-file-cloud-download",
			permissions: ["downloads"]
		},
		{
			name: "top_sites",
			enabled: false,
			template: "src/templates/cards/TopSitesCard.html",
			icon: "mdi-social-whatshot",
			permissions: ["topSites"]
		},
		{
			name: "history",
			enabled: false,
			template: "src/templates/cards/HistoryCard.html",
			icon: "mdi-action-history",
			permissions: ["history"]
		},
		{
			name: "sessions",
			enabled: false,
			template: "src/templates/cards/SessionsCard.html",
			icon: "mdi-device-devices",
			permissions: ["sessions", "tabs"]
		},
		{
			name: "system",
			enabled: false,
			template: "src/templates/cards/SystemCard.html",
			icon: "mdi-hardware-memory",
			permissions: ["system.cpu", "system.memory", "system.storage"]
		},
		{name: "changelog", system: true, enabled: false, template: "src/templates/cards/ChangelogCard.html" }
	],
	faviconURL: "https://www.google.com/s2/favicons?domain_url="
});
